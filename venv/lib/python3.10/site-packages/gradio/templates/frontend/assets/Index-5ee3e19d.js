import { B as Block } from './Button-ab11cb83.js';
import { S as Static } from './Index-a77cc637.js';
import { B as BlockLabel } from './BlockLabel-f22cfddb.js';
import { I as IconButton } from './IconButton-1ba1e4af.js';
import { E as Empty } from './Empty-fef21b7d.js';
import { S as ShareButton } from './ShareButton-92b4d41a.js';
import { D as Download } from './Download-ea83bae3.js';
import { I as Image } from './Image-6cbf81d1.js';
import { n as normalise_file } from './index-9dc32a9d.js';
/* empty css                                                     */import { M as ModifyUpload } from './ModifyUpload-ddd7e65e.js';
import { d as dequal } from './index-f38d9616.js';
import { u as uploadToHuggingFace } from './utils-8f25e669.js';
import './svelte/svelte.js';
import './Clear-9760deed.js';
import './Undo-6c110254.js';

async function format_gallery_for_sharing(value) {
  if (!value)
    return "";
  let urls = await Promise.all(
    value.map(async ([image, _]) => {
      if (image === null || !image.url)
        return "";
      return await uploadToHuggingFace(image.url, "url");
    })
  );
  return `<div style="display: flex; flex-wrap: wrap; gap: 16px">${urls.map((url) => `<img src="${url}" style="height: 400px" />`).join("")}</div>`;
}

const Gallery_svelte_svelte_type_style_lang = '';

/* home/runner/work/gradio/gradio/js/gallery/shared/Gallery.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent: SvelteComponent$1,
	add_iframe_resize_listener,
	add_render_callback,
	append,
	attr,
	binding_callbacks: binding_callbacks$1,
	bubble,
	check_outros,
	create_component: create_component$1,
	destroy_component: destroy_component$1,
	destroy_each,
	detach: detach$1,
	element,
	empty,
	ensure_array_like,
	globals,
	group_outros,
	init: init$1,
	insert: insert$1,
	listen,
	mount_component: mount_component$1,
	run_all,
	safe_not_equal: safe_not_equal$1,
	set_data,
	set_style,
	space: space$1,
	src_url_equal,
	text,
	toggle_class,
	transition_in: transition_in$1,
	transition_out: transition_out$1
} = window.__gradio__svelte__internal;
const { window: window_1 } = globals;
const { createEventDispatcher: createEventDispatcher$1 } = window.__gradio__svelte__internal;const { tick } = window.__gradio__svelte__internal;
function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[41] = list[i];
	child_ctx[43] = i;
	return child_ctx;
}

function get_each_context_1(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[44] = list[i];
	child_ctx[45] = list;
	child_ctx[43] = i;
	return child_ctx;
}

// (168:0) {#if show_label}
function create_if_block_6(ctx) {
	let blocklabel;
	let current;

	blocklabel = new BlockLabel({
			props: {
				show_label: /*show_label*/ ctx[1],
				Icon: Image,
				label: /*label*/ ctx[2] || "Gallery"
			}
		});

	return {
		c() {
			create_component$1(blocklabel.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(blocklabel, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const blocklabel_changes = {};
			if (dirty[0] & /*show_label*/ 2) blocklabel_changes.show_label = /*show_label*/ ctx[1];
			if (dirty[0] & /*label*/ 4) blocklabel_changes.label = /*label*/ ctx[2] || "Gallery";
			blocklabel.$set(blocklabel_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(blocklabel.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(blocklabel.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(blocklabel, detaching);
		}
	};
}

// (173:0) {:else}
function create_else_block(ctx) {
	let t0;
	let div1;
	let div0;
	let t1;
	let div1_resize_listener;
	let current;
	let if_block0 = /*selected_image*/ ctx[17] && /*allow_preview*/ ctx[7] && create_if_block_3(ctx);
	let if_block1 = /*show_share_button*/ ctx[9] && create_if_block_2(ctx);
	let each_value = ensure_array_like(/*resolved_value*/ ctx[12]);
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	return {
		c() {
			if (if_block0) if_block0.c();
			t0 = space$1();
			div1 = element("div");
			div0 = element("div");
			if (if_block1) if_block1.c();
			t1 = space$1();

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "grid-container svelte-1vz630");
			set_style(div0, "--grid-cols", /*columns*/ ctx[4]);
			set_style(div0, "--grid-rows", /*rows*/ ctx[5]);
			set_style(div0, "--object-fit", /*object_fit*/ ctx[8]);
			set_style(div0, "height", /*height*/ ctx[6]);
			toggle_class(div0, "pt-6", /*show_label*/ ctx[1]);
			attr(div1, "class", "grid-wrap svelte-1vz630");
			add_render_callback(() => /*div1_elementresize_handler*/ ctx[36].call(div1));
			toggle_class(div1, "fixed-height", !/*height*/ ctx[6] || /*height*/ ctx[6] == "auto");
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert$1(target, t0, anchor);
			insert$1(target, div1, anchor);
			append(div1, div0);
			if (if_block1) if_block1.m(div0, null);
			append(div0, t1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div0, null);
				}
			}

			div1_resize_listener = add_iframe_resize_listener(div1, /*div1_elementresize_handler*/ ctx[36].bind(div1));
			current = true;
		},
		p(ctx, dirty) {
			if (/*selected_image*/ ctx[17] && /*allow_preview*/ ctx[7]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*selected_image, allow_preview*/ 131200) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_3(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(t0.parentNode, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			if (/*show_share_button*/ ctx[9]) {
				if (if_block1) {
					if_block1.p(ctx, dirty);

					if (dirty[0] & /*show_share_button*/ 512) {
						transition_in$1(if_block1, 1);
					}
				} else {
					if_block1 = create_if_block_2(ctx);
					if_block1.c();
					transition_in$1(if_block1, 1);
					if_block1.m(div0, t1);
				}
			} else if (if_block1) {
				group_outros();

				transition_out$1(if_block1, 1, 1, () => {
					if_block1 = null;
				});

				check_outros();
			}

			if (dirty[0] & /*resolved_value, selected_index*/ 4097) {
				each_value = ensure_array_like(/*resolved_value*/ ctx[12]);
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div0, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (!current || dirty[0] & /*columns*/ 16) {
				set_style(div0, "--grid-cols", /*columns*/ ctx[4]);
			}

			if (!current || dirty[0] & /*rows*/ 32) {
				set_style(div0, "--grid-rows", /*rows*/ ctx[5]);
			}

			if (!current || dirty[0] & /*object_fit*/ 256) {
				set_style(div0, "--object-fit", /*object_fit*/ ctx[8]);
			}

			if (!current || dirty[0] & /*height*/ 64) {
				set_style(div0, "height", /*height*/ ctx[6]);
			}

			if (!current || dirty[0] & /*show_label*/ 2) {
				toggle_class(div0, "pt-6", /*show_label*/ ctx[1]);
			}

			if (!current || dirty[0] & /*height*/ 64) {
				toggle_class(div1, "fixed-height", !/*height*/ ctx[6] || /*height*/ ctx[6] == "auto");
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(if_block1);
			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t0);
				detach$1(div1);
			}

			if (if_block0) if_block0.d(detaching);
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
			div1_resize_listener();
		}
	};
}

// (171:0) {#if value == null || resolved_value == null || resolved_value.length === 0}
function create_if_block(ctx) {
	let empty_1;
	let current;

	empty_1 = new Empty({
			props: {
				unpadded_box: true,
				size: "large",
				$$slots: { default: [create_default_slot$1] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component$1(empty_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(empty_1, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const empty_1_changes = {};

			if (dirty[1] & /*$$scope*/ 32768) {
				empty_1_changes.$$scope = { dirty, ctx };
			}

			empty_1.$set(empty_1_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(empty_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(empty_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(empty_1, detaching);
		}
	};
}

// (174:1) {#if selected_image && allow_preview}
function create_if_block_3(ctx) {
	let button1;
	let div0;
	let t0;
	let modifyupload;
	let t1;
	let button0;
	let img;
	let img_src_value;
	let img_alt_value;
	let img_title_value;
	let t2;
	let t3;
	let div1;
	let current;
	let mounted;
	let dispose;
	let if_block0 = /*show_download_button*/ ctx[10] && create_if_block_5(ctx);

	modifyupload = new ModifyUpload({
			props: { i18n: /*i18n*/ ctx[11], absolute: false }
		});

	modifyupload.$on("clear", /*clear_handler*/ ctx[28]);
	let if_block1 = /*selected_image*/ ctx[17]?.caption && create_if_block_4(ctx);
	let each_value_1 = ensure_array_like(/*resolved_value*/ ctx[12]);
	let each_blocks = [];

	for (let i = 0; i < each_value_1.length; i += 1) {
		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
	}

	return {
		c() {
			button1 = element("button");
			div0 = element("div");
			if (if_block0) if_block0.c();
			t0 = space$1();
			create_component$1(modifyupload.$$.fragment);
			t1 = space$1();
			button0 = element("button");
			img = element("img");
			t2 = space$1();
			if (if_block1) if_block1.c();
			t3 = space$1();
			div1 = element("div");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			attr(div0, "class", "icon-buttons svelte-1vz630");
			attr(img, "data-testid", "detailed-image");
			if (!src_url_equal(img.src, img_src_value = /*selected_image*/ ctx[17].image.url)) attr(img, "src", img_src_value);
			attr(img, "alt", img_alt_value = /*selected_image*/ ctx[17].caption || "");
			attr(img, "title", img_title_value = /*selected_image*/ ctx[17].caption || null);
			attr(img, "loading", "lazy");
			attr(img, "class", "svelte-1vz630");
			toggle_class(img, "with-caption", !!/*selected_image*/ ctx[17].caption);
			attr(button0, "class", "image-button svelte-1vz630");
			set_style(button0, "height", "calc(100% - " + (/*selected_image*/ ctx[17].caption ? '80px' : '60px') + ")");
			attr(button0, "aria-label", "detailed view of selected image");
			attr(div1, "class", "thumbnails scroll-hide svelte-1vz630");
			attr(div1, "data-testid", "container_el");
			attr(button1, "class", "preview svelte-1vz630");
		},
		m(target, anchor) {
			insert$1(target, button1, anchor);
			append(button1, div0);
			if (if_block0) if_block0.m(div0, null);
			append(div0, t0);
			mount_component$1(modifyupload, div0, null);
			append(button1, t1);
			append(button1, button0);
			append(button0, img);
			append(button1, t2);
			if (if_block1) if_block1.m(button1, null);
			append(button1, t3);
			append(button1, div1);

			for (let i = 0; i < each_blocks.length; i += 1) {
				if (each_blocks[i]) {
					each_blocks[i].m(div1, null);
				}
			}

			/*div1_binding*/ ctx[32](div1);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*click_handler_1*/ ctx[29]),
					listen(button1, "keydown", /*on_keydown*/ ctx[19])
				];

				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*show_download_button*/ ctx[10]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*show_download_button*/ 1024) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_5(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(div0, t0);
				}
			} else if (if_block0) {
				group_outros();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			const modifyupload_changes = {};
			if (dirty[0] & /*i18n*/ 2048) modifyupload_changes.i18n = /*i18n*/ ctx[11];
			modifyupload.$set(modifyupload_changes);

			if (!current || dirty[0] & /*selected_image*/ 131072 && !src_url_equal(img.src, img_src_value = /*selected_image*/ ctx[17].image.url)) {
				attr(img, "src", img_src_value);
			}

			if (!current || dirty[0] & /*selected_image*/ 131072 && img_alt_value !== (img_alt_value = /*selected_image*/ ctx[17].caption || "")) {
				attr(img, "alt", img_alt_value);
			}

			if (!current || dirty[0] & /*selected_image*/ 131072 && img_title_value !== (img_title_value = /*selected_image*/ ctx[17].caption || null)) {
				attr(img, "title", img_title_value);
			}

			if (!current || dirty[0] & /*selected_image*/ 131072) {
				toggle_class(img, "with-caption", !!/*selected_image*/ ctx[17].caption);
			}

			if (!current || dirty[0] & /*selected_image*/ 131072) {
				set_style(button0, "height", "calc(100% - " + (/*selected_image*/ ctx[17].caption ? '80px' : '60px') + ")");
			}

			if (/*selected_image*/ ctx[17]?.caption) {
				if (if_block1) {
					if_block1.p(ctx, dirty);
				} else {
					if_block1 = create_if_block_4(ctx);
					if_block1.c();
					if_block1.m(button1, t3);
				}
			} else if (if_block1) {
				if_block1.d(1);
				if_block1 = null;
			}

			if (dirty[0] & /*resolved_value, el, selected_index*/ 12289) {
				each_value_1 = ensure_array_like(/*resolved_value*/ ctx[12]);
				let i;

				for (i = 0; i < each_value_1.length; i += 1) {
					const child_ctx = get_each_context_1(ctx, each_value_1, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block_1(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(div1, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value_1.length;
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(modifyupload.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(modifyupload.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(button1);
			}

			if (if_block0) if_block0.d();
			destroy_component$1(modifyupload);
			if (if_block1) if_block1.d();
			destroy_each(each_blocks, detaching);
			/*div1_binding*/ ctx[32](null);
			mounted = false;
			run_all(dispose);
		}
	};
}

// (177:4) {#if show_download_button}
function create_if_block_5(ctx) {
	let div;
	let iconbutton;
	let current;

	iconbutton = new IconButton({
			props: {
				Icon: Download,
				label: /*i18n*/ ctx[11]("common.download")
			}
		});

	iconbutton.$on("click", /*click_handler*/ ctx[27]);

	return {
		c() {
			div = element("div");
			create_component$1(iconbutton.$$.fragment);
			attr(div, "class", "download-button-container svelte-1vz630");
		},
		m(target, anchor) {
			insert$1(target, div, anchor);
			mount_component$1(iconbutton, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const iconbutton_changes = {};
			if (dirty[0] & /*i18n*/ 2048) iconbutton_changes.label = /*i18n*/ ctx[11]("common.download");
			iconbutton.$set(iconbutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(iconbutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(iconbutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div);
			}

			destroy_component$1(iconbutton);
		}
	};
}

// (217:3) {#if selected_image?.caption}
function create_if_block_4(ctx) {
	let caption;
	let t_value = /*selected_image*/ ctx[17].caption + "";
	let t;

	return {
		c() {
			caption = element("caption");
			t = text(t_value);
			attr(caption, "class", "caption svelte-1vz630");
		},
		m(target, anchor) {
			insert$1(target, caption, anchor);
			append(caption, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*selected_image*/ 131072 && t_value !== (t_value = /*selected_image*/ ctx[17].caption + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach$1(caption);
			}
		}
	};
}

// (227:4) {#each resolved_value as image, i}
function create_each_block_1(ctx) {
	let button;
	let img;
	let img_src_value;
	let img_title_value;
	let t;
	let button_aria_label_value;
	let i = /*i*/ ctx[43];
	let mounted;
	let dispose;
	const assign_button = () => /*button_binding*/ ctx[30](button, i);
	const unassign_button = () => /*button_binding*/ ctx[30](null, i);

	function click_handler_2() {
		return /*click_handler_2*/ ctx[31](/*i*/ ctx[43]);
	}

	return {
		c() {
			button = element("button");
			img = element("img");
			t = space$1();
			if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[44].image.url)) attr(img, "src", img_src_value);
			attr(img, "title", img_title_value = /*image*/ ctx[44].caption || null);
			attr(img, "data-testid", "thumbnail " + (/*i*/ ctx[43] + 1));
			attr(img, "alt", "");
			attr(img, "loading", "lazy");
			attr(img, "class", "svelte-1vz630");
			attr(button, "class", "thumbnail-item thumbnail-small svelte-1vz630");
			attr(button, "aria-label", button_aria_label_value = "Thumbnail " + (/*i*/ ctx[43] + 1) + " of " + /*resolved_value*/ ctx[12].length);
			toggle_class(button, "selected", /*selected_index*/ ctx[0] === /*i*/ ctx[43]);
		},
		m(target, anchor) {
			insert$1(target, button, anchor);
			append(button, img);
			append(button, t);
			assign_button();

			if (!mounted) {
				dispose = listen(button, "click", click_handler_2);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*resolved_value*/ 4096 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[44].image.url)) {
				attr(img, "src", img_src_value);
			}

			if (dirty[0] & /*resolved_value*/ 4096 && img_title_value !== (img_title_value = /*image*/ ctx[44].caption || null)) {
				attr(img, "title", img_title_value);
			}

			if (dirty[0] & /*resolved_value*/ 4096 && button_aria_label_value !== (button_aria_label_value = "Thumbnail " + (/*i*/ ctx[43] + 1) + " of " + /*resolved_value*/ ctx[12].length)) {
				attr(button, "aria-label", button_aria_label_value);
			}

			if (i !== /*i*/ ctx[43]) {
				unassign_button();
				i = /*i*/ ctx[43];
				assign_button();
			}

			if (dirty[0] & /*selected_index*/ 1) {
				toggle_class(button, "selected", /*selected_index*/ ctx[0] === /*i*/ ctx[43]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach$1(button);
			}

			unassign_button();
			mounted = false;
			dispose();
		}
	};
}

// (258:3) {#if show_share_button}
function create_if_block_2(ctx) {
	let div;
	let sharebutton;
	let current;

	sharebutton = new ShareButton({
			props: {
				i18n: /*i18n*/ ctx[11],
				value: /*resolved_value*/ ctx[12],
				formatter: format_gallery_for_sharing
			}
		});

	sharebutton.$on("share", /*share_handler*/ ctx[33]);
	sharebutton.$on("error", /*error_handler*/ ctx[34]);

	return {
		c() {
			div = element("div");
			create_component$1(sharebutton.$$.fragment);
			attr(div, "class", "icon-button svelte-1vz630");
		},
		m(target, anchor) {
			insert$1(target, div, anchor);
			mount_component$1(sharebutton, div, null);
			current = true;
		},
		p(ctx, dirty) {
			const sharebutton_changes = {};
			if (dirty[0] & /*i18n*/ 2048) sharebutton_changes.i18n = /*i18n*/ ctx[11];
			if (dirty[0] & /*resolved_value*/ 4096) sharebutton_changes.value = /*resolved_value*/ ctx[12];
			sharebutton.$set(sharebutton_changes);
		},
		i(local) {
			if (current) return;
			transition_in$1(sharebutton.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(sharebutton.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(div);
			}

			destroy_component$1(sharebutton);
		}
	};
}

// (283:5) {#if entry.caption}
function create_if_block_1(ctx) {
	let div;
	let t_value = /*entry*/ ctx[41].caption + "";
	let t;

	return {
		c() {
			div = element("div");
			t = text(t_value);
			attr(div, "class", "caption-label svelte-1vz630");
		},
		m(target, anchor) {
			insert$1(target, div, anchor);
			append(div, t);
		},
		p(ctx, dirty) {
			if (dirty[0] & /*resolved_value*/ 4096 && t_value !== (t_value = /*entry*/ ctx[41].caption + "")) set_data(t, t_value);
		},
		d(detaching) {
			if (detaching) {
				detach$1(div);
			}
		}
	};
}

// (269:3) {#each resolved_value as entry, i}
function create_each_block(ctx) {
	let button;
	let img;
	let img_alt_value;
	let img_src_value;
	let t0;
	let t1;
	let button_aria_label_value;
	let mounted;
	let dispose;
	let if_block = /*entry*/ ctx[41].caption && create_if_block_1(ctx);

	function click_handler_3() {
		return /*click_handler_3*/ ctx[35](/*i*/ ctx[43]);
	}

	return {
		c() {
			button = element("button");
			img = element("img");
			t0 = space$1();
			if (if_block) if_block.c();
			t1 = space$1();
			attr(img, "alt", img_alt_value = /*entry*/ ctx[41].caption || "");

			if (!src_url_equal(img.src, img_src_value = typeof /*entry*/ ctx[41].image === "string"
			? /*entry*/ ctx[41].image
			: /*entry*/ ctx[41].image.url)) attr(img, "src", img_src_value);

			attr(img, "loading", "lazy");
			attr(img, "class", "svelte-1vz630");
			attr(button, "class", "thumbnail-item thumbnail-lg svelte-1vz630");
			attr(button, "aria-label", button_aria_label_value = "Thumbnail " + (/*i*/ ctx[43] + 1) + " of " + /*resolved_value*/ ctx[12].length);
			toggle_class(button, "selected", /*selected_index*/ ctx[0] === /*i*/ ctx[43]);
		},
		m(target, anchor) {
			insert$1(target, button, anchor);
			append(button, img);
			append(button, t0);
			if (if_block) if_block.m(button, null);
			append(button, t1);

			if (!mounted) {
				dispose = listen(button, "click", click_handler_3);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;

			if (dirty[0] & /*resolved_value*/ 4096 && img_alt_value !== (img_alt_value = /*entry*/ ctx[41].caption || "")) {
				attr(img, "alt", img_alt_value);
			}

			if (dirty[0] & /*resolved_value*/ 4096 && !src_url_equal(img.src, img_src_value = typeof /*entry*/ ctx[41].image === "string"
			? /*entry*/ ctx[41].image
			: /*entry*/ ctx[41].image.url)) {
				attr(img, "src", img_src_value);
			}

			if (/*entry*/ ctx[41].caption) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block_1(ctx);
					if_block.c();
					if_block.m(button, t1);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}

			if (dirty[0] & /*resolved_value*/ 4096 && button_aria_label_value !== (button_aria_label_value = "Thumbnail " + (/*i*/ ctx[43] + 1) + " of " + /*resolved_value*/ ctx[12].length)) {
				attr(button, "aria-label", button_aria_label_value);
			}

			if (dirty[0] & /*selected_index*/ 1) {
				toggle_class(button, "selected", /*selected_index*/ ctx[0] === /*i*/ ctx[43]);
			}
		},
		d(detaching) {
			if (detaching) {
				detach$1(button);
			}

			if (if_block) if_block.d();
			mounted = false;
			dispose();
		}
	};
}

// (172:1) <Empty unpadded_box={true} size="large">
function create_default_slot$1(ctx) {
	let image_1;
	let current;
	image_1 = new Image({});

	return {
		c() {
			create_component$1(image_1.$$.fragment);
		},
		m(target, anchor) {
			mount_component$1(image_1, target, anchor);
			current = true;
		},
		i(local) {
			if (current) return;
			transition_in$1(image_1.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out$1(image_1.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component$1(image_1, detaching);
		}
	};
}

function create_fragment$1(ctx) {
	let t;
	let current_block_type_index;
	let if_block1;
	let if_block1_anchor;
	let current;
	let mounted;
	let dispose;
	add_render_callback(/*onwindowresize*/ ctx[26]);
	let if_block0 = /*show_label*/ ctx[1] && create_if_block_6(ctx);
	const if_block_creators = [create_if_block, create_else_block];
	const if_blocks = [];

	function select_block_type(ctx, dirty) {
		if (/*value*/ ctx[3] == null || /*resolved_value*/ ctx[12] == null || /*resolved_value*/ ctx[12].length === 0) return 0;
		return 1;
	}

	current_block_type_index = select_block_type(ctx);
	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

	return {
		c() {
			if (if_block0) if_block0.c();
			t = space$1();
			if_block1.c();
			if_block1_anchor = empty();
		},
		m(target, anchor) {
			if (if_block0) if_block0.m(target, anchor);
			insert$1(target, t, anchor);
			if_blocks[current_block_type_index].m(target, anchor);
			insert$1(target, if_block1_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = listen(window_1, "resize", /*onwindowresize*/ ctx[26]);
				mounted = true;
			}
		},
		p(ctx, dirty) {
			if (/*show_label*/ ctx[1]) {
				if (if_block0) {
					if_block0.p(ctx, dirty);

					if (dirty[0] & /*show_label*/ 2) {
						transition_in$1(if_block0, 1);
					}
				} else {
					if_block0 = create_if_block_6(ctx);
					if_block0.c();
					transition_in$1(if_block0, 1);
					if_block0.m(t.parentNode, t);
				}
			} else if (if_block0) {
				group_outros();

				transition_out$1(if_block0, 1, 1, () => {
					if_block0 = null;
				});

				check_outros();
			}

			let previous_block_index = current_block_type_index;
			current_block_type_index = select_block_type(ctx);

			if (current_block_type_index === previous_block_index) {
				if_blocks[current_block_type_index].p(ctx, dirty);
			} else {
				group_outros();

				transition_out$1(if_blocks[previous_block_index], 1, 1, () => {
					if_blocks[previous_block_index] = null;
				});

				check_outros();
				if_block1 = if_blocks[current_block_type_index];

				if (!if_block1) {
					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
					if_block1.c();
				} else {
					if_block1.p(ctx, dirty);
				}

				transition_in$1(if_block1, 1);
				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
			}
		},
		i(local) {
			if (current) return;
			transition_in$1(if_block0);
			transition_in$1(if_block1);
			current = true;
		},
		o(local) {
			transition_out$1(if_block0);
			transition_out$1(if_block1);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach$1(t);
				detach$1(if_block1_anchor);
			}

			if (if_block0) if_block0.d(detaching);
			if_blocks[current_block_type_index].d(detaching);
			mounted = false;
			dispose();
		}
	};
}

async function download(file_url, name) {
	let response;

	try {
		response = await fetch(file_url);
	} catch(error) {
		if (error instanceof TypeError) {
			// If CORS is not allowed (https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#checking_that_the_fetch_was_successful),
			// open the link in a new tab instead, mimicing the behavior of the `download` attribute for remote URLs,
			// which is not ideal, but a reasonable fallback.
			window.open(file_url, "_blank", "noreferrer");

			return;
		}

		throw error;
	}

	const blob = await response.blob();
	const url = URL.createObjectURL(blob);
	const link = document.createElement("a");
	link.href = url;
	link.download = name;
	link.click();
	URL.revokeObjectURL(url);
}

function instance$1($$self, $$props, $$invalidate) {
	let previous;
	let next;
	let selected_image;
	let { show_label = true } = $$props;
	let { label } = $$props;
	let { root = "" } = $$props;
	let { proxy_url = null } = $$props;
	let { value = null } = $$props;
	let { columns = [2] } = $$props;
	let { rows = undefined } = $$props;
	let { height = "auto" } = $$props;
	let { preview } = $$props;
	let { allow_preview = true } = $$props;
	let { object_fit = "cover" } = $$props;
	let { show_share_button = false } = $$props;
	let { show_download_button = false } = $$props;
	let { i18n } = $$props;
	let { selected_index = null } = $$props;
	const dispatch = createEventDispatcher$1();

	// tracks whether the value of the gallery was reset
	let was_reset = true;

	let resolved_value = null;
	let prev_value = value;

	if (selected_index == null && preview && value?.length) {
		selected_index = 0;
	}

	let old_selected_index = selected_index;

	function handle_preview_click(event) {
		const element = event.target;
		const x = event.clientX;
		const width = element.offsetWidth;
		const centerX = width / 2;

		if (x < centerX) {
			$$invalidate(0, selected_index = previous);
		} else {
			$$invalidate(0, selected_index = next);
		}
	}

	function on_keydown(e) {
		switch (e.code) {
			case "Escape":
				e.preventDefault();
				$$invalidate(0, selected_index = null);
				break;
			case "ArrowLeft":
				e.preventDefault();
				$$invalidate(0, selected_index = previous);
				break;
			case "ArrowRight":
				e.preventDefault();
				$$invalidate(0, selected_index = next);
				break;
		}
	}

	let el = [];
	let container_element;

	async function scroll_to_img(index) {
		if (typeof index !== "number") return;
		await tick();
		if (el[index] === undefined) return;
		el[index]?.focus();
		const { left: container_left, width: container_width } = container_element.getBoundingClientRect();
		const { left, width } = el[index].getBoundingClientRect();
		const relative_left = left - container_left;
		const pos = relative_left + width / 2 - container_width / 2 + container_element.scrollLeft;

		if (container_element && typeof container_element.scrollTo === "function") {
			container_element.scrollTo({
				left: pos < 0 ? 0 : pos,
				behavior: "smooth"
			});
		}
	}

	let client_height = 0;
	let window_height = 0;

	function onwindowresize() {
		$$invalidate(16, window_height = window_1.innerHeight);
	}

	const click_handler = () => {
		const image = selected_image?.image;

		if (image == null) {
			return;
		}

		const { url, orig_name } = image;

		if (url) {
			download(url, orig_name ?? "image");
		}
	};

	const clear_handler = () => $$invalidate(0, selected_index = null);
	const click_handler_1 = event => handle_preview_click(event);

	function button_binding($$value, i) {
		binding_callbacks$1[$$value ? 'unshift' : 'push'](() => {
			el[i] = $$value;
			$$invalidate(13, el);
		});
	}

	const click_handler_2 = i => $$invalidate(0, selected_index = i);

	function div1_binding($$value) {
		binding_callbacks$1[$$value ? 'unshift' : 'push'](() => {
			container_element = $$value;
			$$invalidate(14, container_element);
		});
	}

	function share_handler(event) {
		bubble.call(this, $$self, event);
	}

	function error_handler(event) {
		bubble.call(this, $$self, event);
	}

	const click_handler_3 = i => $$invalidate(0, selected_index = i);

	function div1_elementresize_handler() {
		client_height = this.clientHeight;
		$$invalidate(15, client_height);
	}

	$$self.$$set = $$props => {
		if ('show_label' in $$props) $$invalidate(1, show_label = $$props.show_label);
		if ('label' in $$props) $$invalidate(2, label = $$props.label);
		if ('root' in $$props) $$invalidate(20, root = $$props.root);
		if ('proxy_url' in $$props) $$invalidate(21, proxy_url = $$props.proxy_url);
		if ('value' in $$props) $$invalidate(3, value = $$props.value);
		if ('columns' in $$props) $$invalidate(4, columns = $$props.columns);
		if ('rows' in $$props) $$invalidate(5, rows = $$props.rows);
		if ('height' in $$props) $$invalidate(6, height = $$props.height);
		if ('preview' in $$props) $$invalidate(22, preview = $$props.preview);
		if ('allow_preview' in $$props) $$invalidate(7, allow_preview = $$props.allow_preview);
		if ('object_fit' in $$props) $$invalidate(8, object_fit = $$props.object_fit);
		if ('show_share_button' in $$props) $$invalidate(9, show_share_button = $$props.show_share_button);
		if ('show_download_button' in $$props) $$invalidate(10, show_download_button = $$props.show_download_button);
		if ('i18n' in $$props) $$invalidate(11, i18n = $$props.i18n);
		if ('selected_index' in $$props) $$invalidate(0, selected_index = $$props.selected_index);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty[0] & /*value, was_reset*/ 8388616) {
			$$invalidate(23, was_reset = value == null || value.length === 0 ? true : was_reset);
		}

		if ($$self.$$.dirty[0] & /*value, root, proxy_url*/ 3145736) {
			$$invalidate(12, resolved_value = value == null
			? null
			: value.map(data => ({
					image: normalise_file(data.image, root, proxy_url),
					caption: data.caption
				})));
		}

		if ($$self.$$.dirty[0] & /*prev_value, value, was_reset, preview, selected_index*/ 29360137) {
			if (!dequal(prev_value, value)) {
				// When value is falsy (clear button or first load),
				// preview determines the selected image
				if (was_reset) {
					$$invalidate(0, selected_index = preview && value?.length ? 0 : null);
					$$invalidate(23, was_reset = false);
				} else // gallery has at least as many elements as it did before
				{
					$$invalidate(
						0,
						selected_index = selected_index != null && value != null && selected_index < value.length
						? selected_index
						: null
					);
				}

				dispatch("change");
				$$invalidate(24, prev_value = value);
			}
		}

		if ($$self.$$.dirty[0] & /*selected_index, resolved_value*/ 4097) {
			previous = ((selected_index ?? 0) + (resolved_value?.length ?? 0) - 1) % (resolved_value?.length ?? 0);
		}

		if ($$self.$$.dirty[0] & /*selected_index, resolved_value*/ 4097) {
			next = ((selected_index ?? 0) + 1) % (resolved_value?.length ?? 0);
		}

		if ($$self.$$.dirty[0] & /*selected_index, old_selected_index, resolved_value*/ 33558529) {
			{
				if (selected_index !== old_selected_index) {
					$$invalidate(25, old_selected_index = selected_index);

					if (selected_index !== null) {
						dispatch("select", {
							index: selected_index,
							value: resolved_value?.[selected_index]
						});
					}
				}
			}
		}

		if ($$self.$$.dirty[0] & /*allow_preview, selected_index*/ 129) {
			if (allow_preview) {
				scroll_to_img(selected_index);
			}
		}

		if ($$self.$$.dirty[0] & /*selected_index, resolved_value*/ 4097) {
			$$invalidate(17, selected_image = selected_index != null && resolved_value != null
			? resolved_value[selected_index]
			: null);
		}
	};

	return [
		selected_index,
		show_label,
		label,
		value,
		columns,
		rows,
		height,
		allow_preview,
		object_fit,
		show_share_button,
		show_download_button,
		i18n,
		resolved_value,
		el,
		container_element,
		client_height,
		window_height,
		selected_image,
		handle_preview_click,
		on_keydown,
		root,
		proxy_url,
		preview,
		was_reset,
		prev_value,
		old_selected_index,
		onwindowresize,
		click_handler,
		clear_handler,
		click_handler_1,
		button_binding,
		click_handler_2,
		div1_binding,
		share_handler,
		error_handler,
		click_handler_3,
		div1_elementresize_handler
	];
}

class Gallery extends SvelteComponent$1 {
	constructor(options) {
		super();

		init$1(
			this,
			options,
			instance$1,
			create_fragment$1,
			safe_not_equal$1,
			{
				show_label: 1,
				label: 2,
				root: 20,
				proxy_url: 21,
				value: 3,
				columns: 4,
				rows: 5,
				height: 6,
				preview: 22,
				allow_preview: 7,
				object_fit: 8,
				show_share_button: 9,
				show_download_button: 10,
				i18n: 11,
				selected_index: 0
			},
			null,
			[-1, -1]
		);
	}
}

const Gallery$1 = Gallery;

/* home/runner/work/gradio/gradio/js/gallery/Index.svelte generated by Svelte v4.2.2 */
const {
	SvelteComponent,
	add_flush_callback,
	assign,
	bind,
	binding_callbacks,
	create_component,
	destroy_component,
	detach,
	get_spread_object,
	get_spread_update,
	init,
	insert,
	mount_component,
	safe_not_equal,
	space,
	transition_in,
	transition_out
} = window.__gradio__svelte__internal;const { createEventDispatcher } = window.__gradio__svelte__internal;
function create_default_slot(ctx) {
	let statustracker;
	let t;
	let gallery;
	let updating_selected_index;
	let current;

	const statustracker_spread_levels = [
		{
			autoscroll: /*gradio*/ ctx[21].autoscroll
		},
		{ i18n: /*gradio*/ ctx[21].i18n },
		/*loading_status*/ ctx[1]
	];

	let statustracker_props = {};

	for (let i = 0; i < statustracker_spread_levels.length; i += 1) {
		statustracker_props = assign(statustracker_props, statustracker_spread_levels[i]);
	}

	statustracker = new Static({ props: statustracker_props });

	function gallery_selected_index_binding(value) {
		/*gallery_selected_index_binding*/ ctx[22](value);
	}

	let gallery_props = {
		label: /*label*/ ctx[3],
		value: /*value*/ ctx[9],
		show_label: /*show_label*/ ctx[2],
		root: /*root*/ ctx[4],
		proxy_url: /*proxy_url*/ ctx[5],
		columns: /*columns*/ ctx[13],
		rows: /*rows*/ ctx[14],
		height: /*height*/ ctx[15],
		preview: /*preview*/ ctx[16],
		object_fit: /*object_fit*/ ctx[18],
		allow_preview: /*allow_preview*/ ctx[17],
		show_share_button: /*show_share_button*/ ctx[19],
		show_download_button: /*show_download_button*/ ctx[20],
		i18n: /*gradio*/ ctx[21].i18n
	};

	if (/*selected_index*/ ctx[0] !== void 0) {
		gallery_props.selected_index = /*selected_index*/ ctx[0];
	}

	gallery = new Gallery$1({ props: gallery_props });
	binding_callbacks.push(() => bind(gallery, 'selected_index', gallery_selected_index_binding));
	gallery.$on("change", /*change_handler*/ ctx[23]);
	gallery.$on("select", /*select_handler*/ ctx[24]);
	gallery.$on("share", /*share_handler*/ ctx[25]);
	gallery.$on("error", /*error_handler*/ ctx[26]);

	return {
		c() {
			create_component(statustracker.$$.fragment);
			t = space();
			create_component(gallery.$$.fragment);
		},
		m(target, anchor) {
			mount_component(statustracker, target, anchor);
			insert(target, t, anchor);
			mount_component(gallery, target, anchor);
			current = true;
		},
		p(ctx, dirty) {
			const statustracker_changes = (dirty & /*gradio, loading_status*/ 2097154)
			? get_spread_update(statustracker_spread_levels, [
					dirty & /*gradio*/ 2097152 && {
						autoscroll: /*gradio*/ ctx[21].autoscroll
					},
					dirty & /*gradio*/ 2097152 && { i18n: /*gradio*/ ctx[21].i18n },
					dirty & /*loading_status*/ 2 && get_spread_object(/*loading_status*/ ctx[1])
				])
			: {};

			statustracker.$set(statustracker_changes);
			const gallery_changes = {};
			if (dirty & /*label*/ 8) gallery_changes.label = /*label*/ ctx[3];
			if (dirty & /*value*/ 512) gallery_changes.value = /*value*/ ctx[9];
			if (dirty & /*show_label*/ 4) gallery_changes.show_label = /*show_label*/ ctx[2];
			if (dirty & /*root*/ 16) gallery_changes.root = /*root*/ ctx[4];
			if (dirty & /*proxy_url*/ 32) gallery_changes.proxy_url = /*proxy_url*/ ctx[5];
			if (dirty & /*columns*/ 8192) gallery_changes.columns = /*columns*/ ctx[13];
			if (dirty & /*rows*/ 16384) gallery_changes.rows = /*rows*/ ctx[14];
			if (dirty & /*height*/ 32768) gallery_changes.height = /*height*/ ctx[15];
			if (dirty & /*preview*/ 65536) gallery_changes.preview = /*preview*/ ctx[16];
			if (dirty & /*object_fit*/ 262144) gallery_changes.object_fit = /*object_fit*/ ctx[18];
			if (dirty & /*allow_preview*/ 131072) gallery_changes.allow_preview = /*allow_preview*/ ctx[17];
			if (dirty & /*show_share_button*/ 524288) gallery_changes.show_share_button = /*show_share_button*/ ctx[19];
			if (dirty & /*show_download_button*/ 1048576) gallery_changes.show_download_button = /*show_download_button*/ ctx[20];
			if (dirty & /*gradio*/ 2097152) gallery_changes.i18n = /*gradio*/ ctx[21].i18n;

			if (!updating_selected_index && dirty & /*selected_index*/ 1) {
				updating_selected_index = true;
				gallery_changes.selected_index = /*selected_index*/ ctx[0];
				add_flush_callback(() => updating_selected_index = false);
			}

			gallery.$set(gallery_changes);
		},
		i(local) {
			if (current) return;
			transition_in(statustracker.$$.fragment, local);
			transition_in(gallery.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(statustracker.$$.fragment, local);
			transition_out(gallery.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) {
				detach(t);
			}

			destroy_component(statustracker, detaching);
			destroy_component(gallery, detaching);
		}
	};
}

function create_fragment(ctx) {
	let block;
	let current;

	block = new Block({
			props: {
				visible: /*visible*/ ctx[8],
				variant: "solid",
				padding: false,
				elem_id: /*elem_id*/ ctx[6],
				elem_classes: /*elem_classes*/ ctx[7],
				container: /*container*/ ctx[10],
				scale: /*scale*/ ctx[11],
				min_width: /*min_width*/ ctx[12],
				allow_overflow: false,
				height: typeof /*height*/ ctx[15] === "number"
				? /*height*/ ctx[15]
				: undefined,
				$$slots: { default: [create_default_slot] },
				$$scope: { ctx }
			}
		});

	return {
		c() {
			create_component(block.$$.fragment);
		},
		m(target, anchor) {
			mount_component(block, target, anchor);
			current = true;
		},
		p(ctx, [dirty]) {
			const block_changes = {};
			if (dirty & /*visible*/ 256) block_changes.visible = /*visible*/ ctx[8];
			if (dirty & /*elem_id*/ 64) block_changes.elem_id = /*elem_id*/ ctx[6];
			if (dirty & /*elem_classes*/ 128) block_changes.elem_classes = /*elem_classes*/ ctx[7];
			if (dirty & /*container*/ 1024) block_changes.container = /*container*/ ctx[10];
			if (dirty & /*scale*/ 2048) block_changes.scale = /*scale*/ ctx[11];
			if (dirty & /*min_width*/ 4096) block_changes.min_width = /*min_width*/ ctx[12];

			if (dirty & /*height*/ 32768) block_changes.height = typeof /*height*/ ctx[15] === "number"
			? /*height*/ ctx[15]
			: undefined;

			if (dirty & /*$$scope, label, value, show_label, root, proxy_url, columns, rows, height, preview, object_fit, allow_preview, show_share_button, show_download_button, gradio, selected_index, loading_status*/ 272622143) {
				block_changes.$$scope = { dirty, ctx };
			}

			block.$set(block_changes);
		},
		i(local) {
			if (current) return;
			transition_in(block.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(block.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			destroy_component(block, detaching);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	let { loading_status } = $$props;
	let { show_label } = $$props;
	let { label } = $$props;
	let { root } = $$props;
	let { proxy_url } = $$props;
	let { elem_id = "" } = $$props;
	let { elem_classes = [] } = $$props;
	let { visible = true } = $$props;
	let { value = null } = $$props;
	let { container = true } = $$props;
	let { scale = null } = $$props;
	let { min_width = undefined } = $$props;
	let { columns = [2] } = $$props;
	let { rows = undefined } = $$props;
	let { height = "auto" } = $$props;
	let { preview } = $$props;
	let { allow_preview = true } = $$props;
	let { selected_index = null } = $$props;
	let { object_fit = "cover" } = $$props;
	let { show_share_button = false } = $$props;
	let { show_download_button = false } = $$props;
	let { gradio } = $$props;
	const dispatch = createEventDispatcher();

	function gallery_selected_index_binding(value) {
		selected_index = value;
		$$invalidate(0, selected_index);
	}

	const change_handler = () => gradio.dispatch("change", value);
	const select_handler = e => gradio.dispatch("select", e.detail);
	const share_handler = e => gradio.dispatch("share", e.detail);
	const error_handler = e => gradio.dispatch("error", e.detail);

	$$self.$$set = $$props => {
		if ('loading_status' in $$props) $$invalidate(1, loading_status = $$props.loading_status);
		if ('show_label' in $$props) $$invalidate(2, show_label = $$props.show_label);
		if ('label' in $$props) $$invalidate(3, label = $$props.label);
		if ('root' in $$props) $$invalidate(4, root = $$props.root);
		if ('proxy_url' in $$props) $$invalidate(5, proxy_url = $$props.proxy_url);
		if ('elem_id' in $$props) $$invalidate(6, elem_id = $$props.elem_id);
		if ('elem_classes' in $$props) $$invalidate(7, elem_classes = $$props.elem_classes);
		if ('visible' in $$props) $$invalidate(8, visible = $$props.visible);
		if ('value' in $$props) $$invalidate(9, value = $$props.value);
		if ('container' in $$props) $$invalidate(10, container = $$props.container);
		if ('scale' in $$props) $$invalidate(11, scale = $$props.scale);
		if ('min_width' in $$props) $$invalidate(12, min_width = $$props.min_width);
		if ('columns' in $$props) $$invalidate(13, columns = $$props.columns);
		if ('rows' in $$props) $$invalidate(14, rows = $$props.rows);
		if ('height' in $$props) $$invalidate(15, height = $$props.height);
		if ('preview' in $$props) $$invalidate(16, preview = $$props.preview);
		if ('allow_preview' in $$props) $$invalidate(17, allow_preview = $$props.allow_preview);
		if ('selected_index' in $$props) $$invalidate(0, selected_index = $$props.selected_index);
		if ('object_fit' in $$props) $$invalidate(18, object_fit = $$props.object_fit);
		if ('show_share_button' in $$props) $$invalidate(19, show_share_button = $$props.show_share_button);
		if ('show_download_button' in $$props) $$invalidate(20, show_download_button = $$props.show_download_button);
		if ('gradio' in $$props) $$invalidate(21, gradio = $$props.gradio);
	};

	$$self.$$.update = () => {
		if ($$self.$$.dirty & /*selected_index*/ 1) {
			(dispatch("prop_change", { selected_index }));
		}
	};

	return [
		selected_index,
		loading_status,
		show_label,
		label,
		root,
		proxy_url,
		elem_id,
		elem_classes,
		visible,
		value,
		container,
		scale,
		min_width,
		columns,
		rows,
		height,
		preview,
		allow_preview,
		object_fit,
		show_share_button,
		show_download_button,
		gradio,
		gallery_selected_index_binding,
		change_handler,
		select_handler,
		share_handler,
		error_handler
	];
}

class Index extends SvelteComponent {
	constructor(options) {
		super();

		init(this, options, instance, create_fragment, safe_not_equal, {
			loading_status: 1,
			show_label: 2,
			label: 3,
			root: 4,
			proxy_url: 5,
			elem_id: 6,
			elem_classes: 7,
			visible: 8,
			value: 9,
			container: 10,
			scale: 11,
			min_width: 12,
			columns: 13,
			rows: 14,
			height: 15,
			preview: 16,
			allow_preview: 17,
			selected_index: 0,
			object_fit: 18,
			show_share_button: 19,
			show_download_button: 20,
			gradio: 21
		});
	}
}

export { Gallery$1 as BaseGallery, Index as default };
//# sourceMappingURL=Index-5ee3e19d.js.map
